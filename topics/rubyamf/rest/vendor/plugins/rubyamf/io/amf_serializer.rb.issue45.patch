Index: amf_serializer.rb
===================================================================
--- amf_serializer.rb	(revision 1260)
+++ amf_serializer.rb	(working copy)
@@ -18,7 +18,7 @@
       end
    
       def reset_referencables
-        @amf0_stored_objects = []
+        @stored_objects = []
         @stored_strings = {} # hash is way faster than array
         @stored_strings[""] = true # add this in automatically
         @floats_cache = {}
@@ -155,16 +155,16 @@
           @stream << "\b" # represents an amf3 date
           write_amf3_date(value)
       
-          # I know we can combine this with the last condition, but don't  ; the Rexml and Beautiful Soup test is expensive, and for large record sets with many AR its better to be able to skip the next step
+        # I know we can combine this with the last condition, but don't; the Rexml and Beautiful Soup test is expensive, and for large record sets with many AR its better to be able to skip the next step
         elsif value.is_a?(ActiveRecord::Base) # Aryk: this way, we can bypass the "['REXML::Document', 'BeautifulSoup'].include?(value.class.to_s) " operation
-          write_amf3_object(VoUtil.get_vo_hash_for_outgoing(value))
+          write_amf3_object(value)
       
         elsif ['REXML::Document', 'BeautifulSoup'].include?(value.class.to_s) 
           write_byte(AMF3_XML)
           write_amf3_xml(value)
 
         elsif value.is_a?(Object)
-          write_amf3_object(VoUtil.get_vo_hash_for_outgoing(value) )
+          write_amf3_object(value)
         end
       end
   
@@ -218,19 +218,28 @@
         end
       end
     
-      def write_amf3_object(hash)   
+      def write_amf3_object(value)
+        hash = value.is_a?(Hash) ? value : VoUtil.get_vo_hash_for_outgoing(value)
         not_vo_hash = !hash.is_a?(VoHash) # is this not a vohash - then doesnt have an _explicitType parameter
-        @stream << "\n\v" # represents an amf3 object and dynamic object  
-        not_vo_hash || !hash._explicitType ? (@stream << "\001") : write_amf3_string(hash._explicitType)
-        hash.each do |attr, value| # Aryk: no need to remove any "_explicitType" or "rmember" key since they werent added as keys
-          if not_vo_hash # then that means that the attr might not be symbols and it hasn't gone through camelizing if thats needed
-            attr = attr.to_s.dup # need this just in case its frozen
-            attr.to_camel! if ClassMappings.translate_case 
+        @stream << "\n\v" # represents an amf3 object and dynamic object
+        # Check if this object has already been written (for circular references)
+        i = @stored_objects.index(value)
+        if i != nil
+          reference = i << 1
+          write_amf3_integer(reference)
+        else
+          @stored_objects << value if !value.is_a?(Hash) # add object here for circular references
+          not_vo_hash || !hash._explicitType ? (@stream << "\001") : write_amf3_string(hash._explicitType)
+          hash.each do |attr, attvalue| # Aryk: no need to remove any "_explicitType" or "rmember" key since they werent added as keys
+            if not_vo_hash # then that means that the attr might not be symbols and it hasn't gone through camelizing if thats needed
+              attr = attr.to_s.dup # need this just in case its frozen
+              attr.to_camel! if ClassMappings.translate_case 
+            end
+            write_amf3_string(attr) 
+            attvalue ? write_amf3(attvalue) : (@stream << "\001") # represents an amf3 null
           end
-          write_amf3_string(attr) 
-          value ? write_amf3(value) : (@stream << "\001") # represents an amf3 null
-        end        
-        @stream << "\001" # represents an amf3 empty string #close open object
+        end
+        @stream << "\001" # represents an amf3 empty string to close open object
       end
   
       def write_amf3_array(array)
@@ -341,4 +350,4 @@
       end
     end
   end
-end
\ No newline at end of file
+end
